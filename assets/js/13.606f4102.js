(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{366:function(t,a,r){"use strict";r.r(a);var s=r(45),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"缓存策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存策略"}},[t._v("#")]),t._v(" 缓存策略")]),t._v(" "),r("hr"),t._v(" "),r("p",[t._v("那如果让我们来设计缓存的策略，首先有两个重要的指标需要考虑。")]),t._v(" "),r("h2",{attrs:{id:"缓存失效"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存失效"}},[t._v("#")]),t._v(" 缓存失效")]),t._v(" "),r("p",[t._v("既然缓存主要是针对数据的复用，那我们就需要有一个条件来判定当前缓存的数据，是否依然有效。\n总是不能一次缓存，终身使用吧，我们还需要在缓存失效之后，重新获取新的数据并进行缓存。这个前提就是，缓存都需要有一个失效的策略。")]),t._v(" "),r("h2",{attrs:{id:"减少读取"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#减少读取"}},[t._v("#")]),t._v(" 减少读取")]),t._v(" "),r("p",[t._v("虽然缓存会有失效策略，但是这只是客户端单方面认为失效，此时应该再去服务端重新获取一遍数据。\n可有些情况下，其实资源可能依然有效，并没有发生变动。那就需要有一个策略，让服务端通知客户端，当前缓存依然有效，可以继续使用。这样在减少传输流量之外，也可以加快相应时间，提高效率。\n这就是一个好的缓存策略必须要考虑的地方，实际上 HTTP 缓存，也是这样设计的。")])])}),[],!1,null,null,null);a.default=e.exports}}]);